# Динамическая оптимизация маршрутов: подробное описание

Этот документ дополняет `README.md` и подробно объясняет, как построен исследовательский стенд `netcalc-dc`, какие математические модели используются, как работают алгоритмы и как выполняются эксперименты локально. Документ можно использовать как техническую спецификацию перед запуском или адаптацией сценариев.

## 1. Математическая модель задержек

### 1.1 Кривые поступления и обслуживания

- **Кривая поступления** (`ArrivalCurve`, `arrival_service.py:18`) описывает поток формулой `α(t) = b + r·t`, где `r` — устойчивая скорость, `b` — ограничение всплеска. Весь трафик в системе приводится к такому виду, что упрощает проверку условий `r < R`.
- **Сервис-кривая** (`ServiceCurve`, `arrival_service.py:48`) задаётся в виде `β(t) = R·max(0, t − T)`. Здесь `R` — гарантированная полоса пропускания канала, `T` — латентность.
- **Конволюция сервисов** (`ServiceCurve.convolve`, `:65`) агрегирует последовательные каналы: новая латентность — сумма `T`, скорость — минимум из `R`. Функция `aggregate_service_curve` (`arrival_service.py:127`) применяет операцию последовательно к маршруту.

### 1.2 Базовая верхняя оценка задержки

Метод `ArrivalCurve.delay_upper_bound` (`arrival_service.py:35`) реализует базовый результат сетевого исчисления: если `r < R`, то верхняя граница задержки `T + b / (R − r)`, иначе задержка считается бесконечной (`∞`). Эта формула используется для первичной оценки маршрута (функция `router.base_delay`, `router.py:35`).

### 1.3 Метод остановки времени (time-stopping)

Чтобы учесть взаимодействие потоков на общих каналах, строится матрица влияния `A` и вектор `a` (`router.influence_matrix`, `router.py:74`). Элементы `A_{ij}` — доля пропускной способности, которую поток `j` «отбирает» у `i` на пересечениях маршрутов. Вектор `a` хранит базовую задержку.

Функция `solve_time_stopping` (`arrival_service.py:101`) проверяет условие `ρ(A) < 1` (спектральный радиус) и решает систему `x = (I − A)^{-1}·a`. Результатом является вектор гарантированных задержек. Если условие нарушено, выбрасывается `TimeStoppingError`, а в метриках фиксируется `∞`.

### 1.4 Метрики

`router.evaluate_assignment` (`router.py:117`) возвращает:
- `max_delay` — максимальная оценка задержки среди всех потоков (после time-stopping).
- `avg_delay` — средняя оценка задержки.
- `sla_violations` — доля потоков, у которых задержка превысила SLA-время.
- `min_capacity_margin` — минимальный запас пропускной способности по маршруту.

Эти показатели собираются во всех сценариях и используются для сравнения алгоритмов.

## 2. Моделирование сети и трафика

### 2.1 Топологии

- `generate_clos` (`topology.py:33`) строит трёхуровневый граф Clos: узлы доступа, агрегации, ядра плюс серверы. Внутри используется `_add_edge`, который сразу создаёт обратные рёбра (граф двунаправленный).
- `generate_fat_tree` (`topology.py:77`) строит регулярную Fat-Tree с параметром `k`. Профили скорости/латентности задаются отдельно для уровней `access`, `aggregation`, `core`.
- Для кастомных сценариев можно загрузить JSON (`load_custom_topology`, `topology.py:168`).
- Функция `k_shortest_paths` (`topology.py:190`) возвращает `k` кратчайших путей по латентности (алгоритм Йена).

### 2.2 Потоки

- `generate_flows` (`flows.py:47`) выбирает пары `source-target` среди серверов, выбирает один из SLA-классов (`DEFAULT_CLASSES`) и генерирует `(r, b)` по усечённому нормальному распределению (`_sample_positive_gaussian`).
- SLA задержка берётся из профиля класса (`interactive`, `batch`, `background`).
- Функция `scale_flows` (`evaluate.py:66`) умножает `r` и `b` на коэффициент `λ`: моделируется глобальный рост нагрузки без изменения SLA.

## 3. Алгоритмы оптимизации

### 3.1 Жадный алгоритм (`greedy`)

Реализован в `heuristics.py:28`. Потоки сортируются по скорости (наиболее «тяжёлые» обрабатываются первыми). Для каждого потока:
1. Рассматриваются маршруты из списка кандидатов (`k`-кратчайшие).
2. Проверяется условие `r < R` и текущая загруженность рёбер (`edge_loads`).
3. Выбирается маршрут с минимальной базовой задержкой. Если ни один не удовлетворяет ограничениям, берётся маршрут с минимальной задержкой без контроля загрузки, чтобы сохранить допустимость.

### 3.2 Локальный поиск (`local_search`)

Использует жадный результат как старт (`heuristics.py:71`). Итеративно выбирает случайный поток и заменяет его маршрут одной из альтернатив; улучшения принимаются, если уменьшается `max_delay + 10 * sla_violations`. Счётчик итераций задаётся параметром `iterations` (по умолчанию 20).

### 3.3 GRASP

Алгоритм `grasp` (`heuristics.py:104`) повторяет две стадии:
1. **Стохастический жадный выбор**: формируется ранжированный список кандидатов (RCL), затем случайно выбирается маршрут из первых `α·|RCL|`.
2. **Локальный поиск**: над построенным решением выполняется `local_search`.

Повторяется `iterations` раз, сохраняется лучшее решение. При экстремальной нагрузке RCL может исчерпаться — тогда бросается `RuntimeError`, который в основном сценарии превращается в предупреждение.

### 3.4 Генетический алгоритм

`genetic_algorithm` (`heuristics.py:187`) кодирует решение хромосомой индексов путей. Основные шаги:
1. **Инициализация**: случайные хромосомы (`population`) с фиксированным seed для воспроизводимости.
2. **Фитнес** (`_fitness`, `heuristics.py:172`): `max_delay + 20 * sla_violations + 1000` (если задержка бесконечна).
3. **Турнирный отбор**, одноточечный кроссовер и простая мутация (`mutation`).
4. **Решение**: лучшая хромосома в финальной популяции конвертируется в маршруты.

Параметры (`GAParams`) задают размер популяции, число поколений, вероятности операторов. Эти значения можно уменьшать для ускорения тестовых запусков.

### 3.5 ILP-базис

Метод `solve_min_max_delay` (`ilp.py:13`) формулирует задачу:
- Переменные `x_{k,p}` — бинарные («поток–маршрут»).
- Ограничения:
  - каждому потоку назначается ровно один маршрут,
  - суммарная скорость на ребре ≤ пропускной способности,
  - задержка каждого маршрута ≤ общей переменной `Z`.
- Цель — минимизировать `Z`.

Решение ищется CBC (PuLP). При невыполнимой модели выдаётся предупреждение; результаты пропускаются.

## 4. Экспериментальный конвейер

### 4.1 Конфигурация

`config.yaml` задаёт:
- тип топологии и её параметры (`fat-tree`, `clos`, `spine-leaf`, `custom`),
- число потоков, seed,
- набор алгоритмов (эвристики, ILP),
- параметры испытаний: `repetitions`, `load_factors`, `k_paths`.

Комментарии в файле поясняют смысл каждого поля (`netcalc_dc/config.yaml`).

### 4.2 Пошаговая логика (`evaluate.py:130`)

1. Загружаем конфигурацию (`load_config`), генерируем граф (`build_topology`).
2. Для каждого повтора `rep` (меняя seed) генерируем базовый набор потоков (`generate_flows`) и кандидатные маршруты (`build_candidates`).
3. Для каждого коэффициента нагрузки `λ` масштабируем потоки (`scale_flows`) и запускаем все алгоритмы (`run_algorithms`).
4. Каждое назначение оценивается `router.evaluate_assignment`. Метрики сохраняются в список `all_records`.
5. Результаты агрегируются в `metrics.csv`.

### 4.3 Отчёты и графики

`main.py` вызывает `evaluate.run_experiment`, затем `save_reports`:
- `summary_by_algorithm.csv` — среднее и стандартное отклонение по алгоритмам.
- `summary_by_load.csv` — усреднение по нагрузкам и алгоритмам.
- `report.md` — Markdown-отчёт:
  - лучшая стратегия (если есть конечные значения),
  - таблицы (с `∞` для недопустимых случаев),
  - интерпретация графиков,
  - текстовые выводы по каждому `λ`.

Функции `plot_delay_vs_load`, `plot_sla_violations` и `plot_sla_heatmap` (`plots.py`) формируют PNG-графики. Первые две визуализируют зависимости в координатах «нагрузка—метрика», а `plot_sla_heatmap` строит тепловую карту доли нарушений SLA по сетке \\(\lambda, k_{\text{paths}}\\).
