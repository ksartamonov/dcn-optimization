# Экспериментальный пайплайн `netcalc_dc` (подробно)

## Входные данные
- **Конфиг** (`config.yaml`, `config_clos.yaml`, …): описание топологии и параметров эксперимента.
- **Топология**:
  - Clos / Fat-Tree / кастом (`topology.type` и `topology.path`).
  - Параметры ёмкости/латентности рёбер: `capacity_profile`, `latency_profile` или значения в JSON для кастомной топологии.
- **Трафик**:
  - Число потоков `flows.count` (в базовых сценариях 32).
  - seed `flows.seed` для воспроизводимости.
  - Параметры потока: пиковая скорость `r_i` и бёрстность `b_i` генерируются из диапазонов в `flows.py`.
  - Масштаб нагрузки `λ` из `evaluation.load_factors` (например 0.4, 0.6, 0.8, 0.95, 1.0).
- **Множество путей**:
  - `evaluation.k_paths` (обычно 5 или 10) — число кандидатов на пару VM.
- **Алгоритмы**:
  - Эвристики: greedy, local_search, GRASP, GA.
  - ILP-бейзлайн (CBC).
  - Таймаут ILP: `algorithms.ilp.timeout` (600 c в базовых конфигах).

## Моделирование трафика и задержек
- Поток $k$: $\alpha_k(t)=b_k+r_k t$, где $r_k$ — пик. битрейт, $b_k$ — бёрстность.
- Ребро $e$: $\beta_e(t)=R_e (t-T_e)^+$, $R_e$ — пропускная способность, $T_e$ — латентность.
- Маршрут $p$: $T(p)=\sum_{e\in p}T_e$, $R_{\min}(p)=\min_{e\in p} R_e$.
- Предварительная оценка задержки (фильтр):
  \[
  W_{k,p} \le \frac{b_k}{R_{\min}(p)-r_k} + T(p), \quad r_k < R_{\min}(p).
  \]
-  Если оценка превышает SLA или $r_k \ge R_{\min}(p)$ — путь удаляется.
- Итоговая оценка и метрики считаются в `router.evaluate_assignment` (макс. задержка, доля нарушений SLA).

### Примечание про time-stopping и $\rho(A)$
В теории (гл.3) вводятся метод остановки времени и критерий $\rho(A)<1$; в текущей реализации эти величины явно не вычисляются. Практическая допустимость обеспечивается фильтрами по пропускной способности/задержке и фактом наличия допустимого решения (эвристики/ILP).

## Постановка задачи (ILP, `ilp.py`)
Переменные: $x_{k,p}\in\{0,1\}$ — выбор пути $p$ для потока $k$; $Z$ — верхняя граница максимальной задержки.
- Цель: $\min Z$.
- Ограничения:
  - $\sum_{p\in \mathcal{P}_k} x_{k,p} = 1$ (один маршрут на поток).
  - $\sum_{k}\sum_{p\ni e} r_k\, x_{k,p} \le R_e$ (capacity на каждом ребре).
  - $\sum_{p\in \mathcal{P}_k} D_{k,p}\, x_{k,p} \le Z$ (задержка потока не превышает $Z$).
  - $x_{k,p}\in\{0,1\}$.
`D_{k,p}` берутся из оценки задержки (после фильтра).

## Генерация путей
1. Построение графа из топологии.
2. Для каждой пары VM — k-кратчайших простых путей (алгоритм Йена, вес = латентность).
3. Фильтрация путей по capacity/latency (см. выше).

## Алгоритмы назначения маршрутов (`heuristics.py`)
- **Greedy**: последовательный выбор лучшего допустимого пути; порядок потоков фиксирован.
- **Local search**: старт с допустимого решения (обычно greedy), до 20 итераций замены пути одному потоку при улучшении метрики (max_delay + штраф).
- **GRASP**: 30 рестартов; на каждой итерации строится рандомизированное жадное решение (параметр α=0.3), затем локальный поиск; выбирается лучшее.
- **GA**:
  - Параметры по умолчанию: популяция 60, поколений 200, кроссовер 0.8, мутация 0.1, турнир 3, seed 7.
  - Кодирует назначение путей хромосомой индексов; фитнесс = max_delay + штраф за SLA + пенальти за \(\infty\).
- **ILP**: решается CBC с таймаутом 600 с; ограничения как выше. Используется как эталон для малых сценариев.

## Метрики
- \(d_{\max}\) — максимальная оценка задержки среди потоков (после выбора маршрутов).
- \(\sigma\) — доля нарушений SLA (потоков с \(d_i > d_i^{SLA}\)).
- Опционально: `duration_ms` для замеров времени (см. `time_suite.py`).

